# Устные Вопросы
## 1. Какой самый эффективный способ конкатенации строк?
Конкатенация в базовом виде - []byte  <br />
```
strings := []string{"This ", "is ", "even ", "more ", "performant "}

bs := make([]byte, 100)
bl := 0

for _, val := range strings {
    bl += copy(bs[bl:], []byte(val))
}

fmt.Println(string(bs[:]))
```
## 2. Что такое интерфейсы, как они применяются в Go?

В Go интерфейсы представляют собой абстрактные типы данных, которые определяют набор методов, которые должны быть
реализованы в других типах данных. Интерфейсы позволяют абстрагировать поведение и описывать только то, что объект может
делать, независимо от его конкретного типа.

Использование интерфейсов позволяет писать гибкий и расширяемый код, так как позволяет работать с разными типами данных,
если они реализуют один и тот же интерфейс. Это также позволяет использовать полиморфизм и облегчает тестирование и
разделение кода на более мелкие компоненты.

## 3. Чем отличаются RWMutex от Mutex?

`RWMutex` обладает большим набором методов: <br />
`RLock()` - блокирует для чтения, `RUnlock()`

## 4. Чем отличаются буферизированные и не буферизированные каналы?
`ch := make(chan Type)` <br />
По умолчанию канал без второго аргуметна (размера буфера) в make является небуферизированным, так как он сразу доступен
для чтения

`ch := make(chan Type, n)` <br />
Буферизированный канал не доступен для чтения пока буфер не будет полностью заполнен. Операция чтения на
буферизированном канале является жадной, таким образом, как только операция чтения началась, она не будет
завершена до полного опустошения буфера.

## 5. Какой размер у структуры struct{}{}?

Так как структура не имеет полей она равна нулю

## 6. Есть ли в Go перегрузка методов или операторов?

Нет, в Go обычно используются именованные функции с разными именами, чтобы выполнять аналогичные действия, но с разными
параметрами или типами данных. Это помогает обеспечить ясность и понятность кода.

## 7. В какой последовательности будут выведены элементы map[int]int?
Пример:
```
m[0]=1
m[1]=124
m[2]=281
```

В разной, так как map в go хранит данные не структурированно.
map  представляет собой хэш-таблицу, которая обеспечивает быстрый доступ к данным по ключу.
Внутренняя реализация  map  в Go не гарантирует порядок элементов при итерации по ним.

## 8. В чем разница make и new?

`new`  используется для выделения памяти для нового объекта и возвращает указатель на этот объект.
Он принимает тип данных в качестве аргумента и возвращает указатель на нулевое значение этого типа.
Например:
```
var p *int
p = new(int)
```
`make` используется для создания и инициализации объектов некоторых встроенных типов данных,
таких как slice, map и channel. Он принимает тип данных, дополнительные аргументы (если необходимо)
и возвращает инициализированный объект.
Например:
`slice := make([]int, 0, 10)`

## 9. Сколько существует способов задать переменную типа slice или map?
4: <br />
slice:
```
s := []int{1, 2, 3}
```
```
s := make([]int, 3, 5)
```
```
var s []int
s = append(s, 1, 2, 3)
```
```
source := []int{1, 2, 3}
s := source[:]
```

map:
```
m := map[string]int{"key1": 1, "key2": 2}
```
```
m := make(map[string]int)
```
```
var m map[string]int
m = make(map[string]int)
```
```
source := map[string]int{"key1": 1, "key2": 2}
m := source
```

## 10. Что выведет данная программа и почему?
```
func update(p *int) {
    b := 2
    p = &b
}
func main() {
    var (
        a = 1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```
Вывод:
```
1
1
```
Данная программа патается поменять значение указателя, присваивая ему адрес переменной b.
Однако по скольку мы передаем в функцию указатель (в go параметры передаются путем копирования),
а не адрес указателя `&p`, мы меняем значение указателя локально

## 11. Что выведет данная программа и почему?
```
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```
Вывод:
```
fatal error: all goroutines are asleep - deadlock!
```
Так как мы передаем в анонимную горутину копию wg, копия обновляется, а оригинальная этого не отслеживает
для решения данной проблемы необходимо передавть wg по ссылке `}(&wg, i)`

## 12. Что выведет данная программа и почему?
```
func main() {
    n := 0
    if true {
        n := 1
        n++ 
    }
    fmt.Println(n)
}
```
Вывод:
```
0
```
Область видимости n в if ограничена областью действия условия if


## 13. Что выведет данная программа и почему?
```
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}
func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
Вывод:
`[100 2 3 4 5]`

Передавая слайс в функцию мы передаем копию len, cap, a массив передается как ссылка
Мы може изменять его содержимое, но добавлять новые - нет (не окажет влияния на базовый)

## 14. Что выведет данная программа и почему?
```    
func main() {
    slice := []string{"a", "a"}
    
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    
    fmt.Print(slice)
}
```
Вывод:
```
[b b a]
[a a]
```
Такая же ситуация как и в 13 вопросе